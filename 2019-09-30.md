# Understanding Password Hashing

Password hashing is something that is often implemented without a true grasp

Our brains can only hold so much information so it's no wonder users today continue with the same, often weak, password for multiple websites. Password hashing is a way for us to ensure

Let's talk about why passwords should be hashed and the best practices around password hashing.

Our brains can only hold so much information. So it's no wonder internet users today continue to use the same password for multiple websites. They often use weak passwords and only strengthen it when validation rules require it, which often don't have the intended effect as instead of `letmein` they'll use `letmein1` or some other weak workaround.

It's easy to scoff and scorn at them as you continue to punch in your 2FA codes and use your password manager (you are using one, right?). However, you are not the average internet user so it requires us to have empathy towards the general public.

As with any sensitive data, it is our responsibility to ensure it is secure, particularly if the user's themselves are not doing so.

## Storing passwords as plain text

We have moved on from the days of storing passwords in plain text and is something that should never be done.

If someone has read access to your database that stored plain text passwords, then it's game over. They have instant access to the credentials with no other measures in place to prevent them from obtaining them.

You might say "well our server is so secure, that would never happen!" Whilst I'm sure every reasonable measure has been taken to ensure security, one can never be certain. Vulnerabilities are raised so often with technologies such as the 2014 Heartbleed bug and even if that weren't true, somewhere within your organisation there read access to the database. An angry employee could easily take these records or have their account compromised through social engineering.

Therefore we need to assume

Not only that, but somewhere within your organisation there is a level of access, granted to one or some, that can access the database records. An angry employee could easily take these records or have their account compromised through social engineering.

There are many other ways this data can be compromised, the point I'm trying to make is that one needs to take measures so that if this data has been compromised, that the attacker is still steps away from obtaining passwords.

So now that's out of the way, let's talk about password hashing.

## What is hashing?

Hashing is a deterministic algorithm that takes data of arbitrary length and turns it into a fixed-length value simply called a hash.

One typical use of a hash is to check the integrity of a file when downloading. You might have noticed somewhere on the download page of a website that an md5 hash is shown. The intention is that once your file is downloaded, you can compute the hash on your local machine, and compare the two. The MD5 hash function is preinstalled on MacOS, so it's as simple as running `md5 ./downloaded_software.iso`. If they do not match, then the file has been tampered with and you probably don't want to mount that iso.

There are several hashing algorithms, with the most popular being `MD5`, `SHA-1`, `SHA-2` and `SHA-3`.

## Why hashing?

Hashing is one-way, meaning it cannot be reversed. Therefore a hacker cannot take a hash and reverse the process in order to get the value. The only way to obtain the value is by computing hashes and making comparisons using clever guesswork.

### Brute Force

In a brute force attack, the attacker generates a hash from an input and compares that hash with the output. An incredibly naive approach might be to first check each character chronologically, `a`, `b`, `c` and then followed by 2 characters `aa`, `ab` etc. This wouldn't be smart because it's highly likely the password validation requires a minimum length and also to speed things up the attacker may start with just the most common 100 passwords on the internet like `querty` and `password123`.

The reality is brute forcing passwords has, and always will be an unsolved problem. But there are ways we can make it really, really hard.


#### Increasing Password Validation

By adding some serious password validation that, we increase the the amount of possible passwords greatly which means more hashes will need to be computed.

#### Use a Slow Hash Function

As engineers we strive for fast code so this may sound counterintuitive, but a property of what makes a good hash function is one that is slow.

The reason we want this is for the same reason, we slow down the brute force time dramatically because the attacker needs to put their CPU to more work. With less passwords per second being able to be computed.

This is why the popular algorithms `MD5`, `SHA-1`, `SHA-2` and `SHA-3` are not suited because they are all fast by design. So instead, use a slow algorithm like `PBKDF2`, `bcrypt` and `scrypt`. `bcrypt` appears to be the most widely used as the computing cannot be accelerated on GPUs as easily.

### Dictionary attack

In a dictionary attack, an attacker creates a list of common passwords and the hashed values of them before even looking at your user table. With this list created, lookups are done to see if any of the hashes generated match the hashes in the user table. What makes a dictionary attack so easy is that the precomputed table that could be used on various hacked user tables that use a simple hashing algorithm.

The way we prevent a dictionary attack is by salting.

## Salting

A salt is a random piece of data used as an additional input to the hash function. Typically the salt is just appended to the end of the password before the main hashing algorithm begins.

Let's opt for the same salt for every user password. We will use bcrypt here with the salt `123`

This is great because a dictionary attack cannot occur as the system is now unique in the way it hashes passwords. However, we do not prevent a rainbow table attack.

A rainbow table attack is also a pre-calculated

### Salt per user

There's a couple of ways you may store this salt. In this approach you add a salt column in your users table. However in some cryptographic hash functions, the salt is actually included as part of the hash itself. For example `bcrypt` appends the salt to the value.

## Peppering

A pepper is a secret key that is used as a third parameter to the hash function. A secret key is not something you would store in your user records or expose for obvious reasons.

This is great if our attacker has limited access to our server. However, if someone has access to our database, it's likely they will have access to the disk and possibly memory, which is where the pepper would be stored. In this case, a compromised secret key results in no increase in security. For this reason peppers are not commonly implemented.

## Summary

-
- Ensure strict validation to force users to use a more complex password.
- Use a slow algorithm
- Have a unique salt per user.
- Add an optional pepper.
